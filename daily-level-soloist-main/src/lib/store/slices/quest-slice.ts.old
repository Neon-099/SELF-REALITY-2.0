import { StateCreator } from 'zustand';
import { Quest, Task, DailyWinCategory, Difficulty, Stat } from '../../types';
import { v4 as uuidv4 } from 'uuid';
import { calculateExpToNextLevel, calculateRank } from '../../utils/calculations';
import { toast } from '@/hooks/use-toast';
import { StoreState } from '../index';
import { expRewards } from '@/data/exp-rewards';
import { MongoDBService } from '../../services/mongodb-service';

export interface QuestSlice {
  quests: Quest[];
  addQuest: (title: string, description: string, isMainQuest?: boolean, difficulty?: Difficulty) => Quest;
  completeQuest: (id: string) => void;
  startQuest: (id: string) => void;
  addQuestTask: (questId: string, taskDescription: string) => void;
  completeQuestTask: (questId: string, taskIndex: number) => void;
  canCompleteQuest: (id: string) => boolean;
  updateQuest: (id: string, updates: Partial<Quest>) => void;
  deleteQuest: (id: string) => void;
  loadQuests: () => Promise<void>;
}

// Helper to map daily win categories to attribute stats
const categoryToStat = (category: DailyWinCategory): Stat => {
  switch(category) {
    case 'mental': return 'emotional';
    case 'physical': return 'physical';
    case 'spiritual': return 'spiritual';
    case 'intelligence': return 'cognitive';
    default: return 'emotional';
  }
};

// Helper to map attribute categories back to daily win categories
const attributeToDailyWin = (attributeCategory: string): DailyWinCategory | null => {
  switch(attributeCategory) {
    case 'physical': return 'physical';
    case 'cognitive': return 'intelligence';
    case 'emotional': return 'mental';
    case 'spiritual': return 'spiritual';
    case 'social': return 'mental'; // Default social to mental
    default: return null;
  }
};

// Use StoreState instead of listing all dependencies for better compatibility
export const createQuestSlice: StateCreator<QuestSlice & any> = (dbService: MongoDBService, set, get) => ({
  quests: [],
  
  loadQuests: async () => {
    try {
      const quests = await dbService.getAllQuests();
      set({ quests });
    } catch (error) {
      console.error('Failed to load quests:', error);
    }
  },

  addQuest: async (title: string, description: string, isMainQuest: boolean = false, difficulty: Difficulty = 'normal') => {
    const quest: Quest = {
      id: uuidv4(),
      title,
      description,
      isMainQuest,
      difficulty,
      createdAt: new Date(),
      completed: false,
      expReward: expRewards[difficulty],
      tasks: [],
      started: false
    };

    try {
      const savedQuest = await dbService.createQuest(quest);
      set((state: QuestSlice) => ({
        quests: [...state.quests, savedQuest]
      }));
      return savedQuest;
    } catch (error) {
      console.error('Failed to add quest:', error);
      return quest;
    }
  },

  completeQuest: async (id: string) => {
    try {
      const updatedQuest = await dbService.updateQuest(id, {
        completed: true,
        completedAt: new Date()
      });

      if (updatedQuest) {
        set((state: QuestSlice) => ({
          quests: state.quests.map(q => q.id === id ? updatedQuest : q)
        }));
      }
    } catch (error) {
      console.error('Failed to complete quest:', error);
    }
  },

  deleteQuest: async (id: string) => {
    try {
      await dbService.deleteQuest(id);
      set((state: QuestSlice) => ({
        quests: state.quests.filter(q => q.id !== id)
      }));
    } catch (error) {
      console.error('Failed to delete quest:', error);
    }
  },

  updateQuest: async (id: string, updates: Partial<Quest>) => {
    try {
      const updatedQuest = await dbService.updateQuest(id, updates);
      if (updatedQuest) {
        set((state: QuestSlice) => ({
          quests: state.quests.map(q => q.id === id ? updatedQuest : q)
        }));
      }
    } catch (error) {
      console.error('Failed to update quest:', error);
    }
  },

  addQuestTask: async (questId: string, taskDescription: string) => {
    try {
      const quest = get().quests.find(q => q.id === questId);
      if (quest) {
        const updatedTasks = [...(quest.tasks || []), { description: taskDescription, completed: false }];
        const updatedQuest = await dbService.updateQuest(questId, { tasks: updatedTasks });
        
        if (updatedQuest) {
          set((state: QuestSlice) => ({
            quests: state.quests.map(q => q.id === questId ? updatedQuest : q)
          }));
        }
      }
    } catch (error) {
      console.error('Failed to add quest task:', error);
    }
  },

  completeQuestTask: async (questId: string, taskIndex: number) => {
    try {
      const quest = get().quests.find(q => q.id === questId);
      if (quest && quest.tasks) {
        const updatedTasks = [...quest.tasks];
        updatedTasks[taskIndex] = { ...updatedTasks[taskIndex], completed: true };
        
        const updatedQuest = await dbService.updateQuest(questId, { tasks: updatedTasks });
        
        if (updatedQuest) {
          set((state: QuestSlice) => ({
            quests: state.quests.map(q => q.id === questId ? updatedQuest : q)
          }));
        }
      }
    } catch (error) {
      console.error('Failed to complete quest task:', error);
    }
  },

  startQuest: (id) => {
    set((state: QuestSlice) => ({
      quests: state.quests.map(quest =>
        quest.id === id ? { ...quest, started: true } : quest
      )
    }));
  },

  canCompleteQuest: (id) => {
    const { quests, areSideQuestsLocked } = get();
    const quest = quests.find(q => q.id === id);
    
    // Quest not found
    if (!quest) return false;
    
    // Check if side quests are locked (only if this is a side quest)
    if (!quest.isMainQuest && areSideQuestsLocked()) {
      toast({
        title: "Side Quests Locked",
        description: "You must complete main quests first to unlock side quests.",
        variant: "destructive"
      });
      return false;
    }
    
    // Already completed
    if (quest.completed) return false;
    
    // If quest has tasks, all tasks must be completed
    if (quest.tasks.length > 0) {
      return quest.tasks.every(task => task.completed);
    }
    
    // Quest with no tasks can be completed
    return true;
  }
});
